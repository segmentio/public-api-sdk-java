/*
 * Segment Public API
 * The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.
 *
 * Contact: friends@segment.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.segment.publicapi.models;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.segment.publicapi.JSON;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import org.openapitools.jackson.nullable.JsonNullable;

/** Represents a field used in configuring an action. */
public class DestinationMetadataActionFieldV1 {
    public static final String SERIALIZED_NAME_ID = "id";

    @SerializedName(SERIALIZED_NAME_ID)
    private String id;

    public static final String SERIALIZED_NAME_SORT_ORDER = "sortOrder";

    @SerializedName(SERIALIZED_NAME_SORT_ORDER)
    private BigDecimal sortOrder;

    public static final String SERIALIZED_NAME_FIELD_KEY = "fieldKey";

    @SerializedName(SERIALIZED_NAME_FIELD_KEY)
    private String fieldKey;

    public static final String SERIALIZED_NAME_LABEL = "label";

    @SerializedName(SERIALIZED_NAME_LABEL)
    private String label;

    /** The data type for this value. */
    @JsonAdapter(TypeEnum.Adapter.class)
    public enum TypeEnum {
        BOOLEAN("BOOLEAN"),

        DATETIME("DATETIME"),

        HIDDEN("HIDDEN"),

        INTEGER("INTEGER"),

        NUMBER("NUMBER"),

        OBJECT("OBJECT"),

        PASSWORD("PASSWORD"),

        STRING("STRING"),

        TEXT("TEXT");

        private String value;

        TypeEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static TypeEnum fromValue(String value) {
            for (TypeEnum b : TypeEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }

        public static class Adapter extends TypeAdapter<TypeEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final TypeEnum enumeration)
                    throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public TypeEnum read(final JsonReader jsonReader) throws IOException {
                String value = jsonReader.nextString();
                return TypeEnum.fromValue(value);
            }
        }
    }

    public static final String SERIALIZED_NAME_TYPE = "type";

    @SerializedName(SERIALIZED_NAME_TYPE)
    private TypeEnum type;

    public static final String SERIALIZED_NAME_DESCRIPTION = "description";

    @SerializedName(SERIALIZED_NAME_DESCRIPTION)
    private String description;

    public static final String SERIALIZED_NAME_PLACEHOLDER = "placeholder";

    @SerializedName(SERIALIZED_NAME_PLACEHOLDER)
    private String placeholder;

    public static final String SERIALIZED_NAME_DEFAULT_VALUE = "defaultValue";

    @SerializedName(SERIALIZED_NAME_DEFAULT_VALUE)
    private Object defaultValue = null;

    public static final String SERIALIZED_NAME_REQUIRED = "required";

    @SerializedName(SERIALIZED_NAME_REQUIRED)
    private Boolean required;

    public static final String SERIALIZED_NAME_MULTIPLE = "multiple";

    @SerializedName(SERIALIZED_NAME_MULTIPLE)
    private Boolean multiple;

    public static final String SERIALIZED_NAME_CHOICES = "choices";

    @SerializedName(SERIALIZED_NAME_CHOICES)
    private Object choices = null;

    public static final String SERIALIZED_NAME_DYNAMIC = "dynamic";

    @SerializedName(SERIALIZED_NAME_DYNAMIC)
    private Boolean dynamic;

    public static final String SERIALIZED_NAME_ALLOW_NULL = "allowNull";

    @SerializedName(SERIALIZED_NAME_ALLOW_NULL)
    private Boolean allowNull;

    public static final String SERIALIZED_NAME_HIDDEN = "hidden";

    @SerializedName(SERIALIZED_NAME_HIDDEN)
    private Boolean hidden;

    public DestinationMetadataActionFieldV1() {}

    public DestinationMetadataActionFieldV1 id(String id) {

        this.id = id;
        return this;
    }

    /**
     * The primary key of the field.
     *
     * @return id
     */
    @javax.annotation.Nonnull
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public DestinationMetadataActionFieldV1 sortOrder(BigDecimal sortOrder) {

        this.sortOrder = sortOrder;
        return this;
    }

    /**
     * The order this particular field is (used in the UI for displaying the fields in a specified
     * order).
     *
     * @return sortOrder
     */
    @javax.annotation.Nonnull
    public BigDecimal getSortOrder() {
        return sortOrder;
    }

    public void setSortOrder(BigDecimal sortOrder) {
        this.sortOrder = sortOrder;
    }

    public DestinationMetadataActionFieldV1 fieldKey(String fieldKey) {

        this.fieldKey = fieldKey;
        return this;
    }

    /**
     * A unique machine-readable key for the field. Should ideally match the expected key in the
     * action\\&#39;s API request.
     *
     * @return fieldKey
     */
    @javax.annotation.Nonnull
    public String getFieldKey() {
        return fieldKey;
    }

    public void setFieldKey(String fieldKey) {
        this.fieldKey = fieldKey;
    }

    public DestinationMetadataActionFieldV1 label(String label) {

        this.label = label;
        return this;
    }

    /**
     * A human-readable label for this value.
     *
     * @return label
     */
    @javax.annotation.Nonnull
    public String getLabel() {
        return label;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public DestinationMetadataActionFieldV1 type(TypeEnum type) {

        this.type = type;
        return this;
    }

    /**
     * The data type for this value.
     *
     * @return type
     */
    @javax.annotation.Nonnull
    public TypeEnum getType() {
        return type;
    }

    public void setType(TypeEnum type) {
        this.type = type;
    }

    public DestinationMetadataActionFieldV1 description(String description) {

        this.description = description;
        return this;
    }

    /**
     * A human-readable description of this value. You can use Markdown.
     *
     * @return description
     */
    @javax.annotation.Nonnull
    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public DestinationMetadataActionFieldV1 placeholder(String placeholder) {

        this.placeholder = placeholder;
        return this;
    }

    /**
     * An example value displayed but not saved.
     *
     * @return placeholder
     */
    @javax.annotation.Nullable
    public String getPlaceholder() {
        return placeholder;
    }

    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }

    public DestinationMetadataActionFieldV1 defaultValue(Object defaultValue) {

        this.defaultValue = defaultValue;
        return this;
    }

    /**
     * A default value that is saved the first time an action is created.
     *
     * @return defaultValue
     */
    @javax.annotation.Nullable
    public Object getDefaultValue() {
        return defaultValue;
    }

    public void setDefaultValue(Object defaultValue) {
        this.defaultValue = defaultValue;
    }

    public DestinationMetadataActionFieldV1 required(Boolean required) {

        this.required = required;
        return this;
    }

    /**
     * Whether this field is required.
     *
     * @return required
     */
    @javax.annotation.Nonnull
    public Boolean getRequired() {
        return required;
    }

    public void setRequired(Boolean required) {
        this.required = required;
    }

    public DestinationMetadataActionFieldV1 multiple(Boolean multiple) {

        this.multiple = multiple;
        return this;
    }

    /**
     * Whether a user can provide multiples of this field.
     *
     * @return multiple
     */
    @javax.annotation.Nonnull
    public Boolean getMultiple() {
        return multiple;
    }

    public void setMultiple(Boolean multiple) {
        this.multiple = multiple;
    }

    public DestinationMetadataActionFieldV1 choices(Object choices) {

        this.choices = choices;
        return this;
    }

    /**
     * A list of machine-readable value/label pairs to populate a static dropdown.
     *
     * @return choices
     */
    @javax.annotation.Nullable
    public Object getChoices() {
        return choices;
    }

    public void setChoices(Object choices) {
        this.choices = choices;
    }

    public DestinationMetadataActionFieldV1 dynamic(Boolean dynamic) {

        this.dynamic = dynamic;
        return this;
    }

    /**
     * Whether this field should execute a dynamic request to fetch choices to populate a dropdown.
     * When true, &#x60;choices&#x60; is ignored.
     *
     * @return dynamic
     */
    @javax.annotation.Nonnull
    public Boolean getDynamic() {
        return dynamic;
    }

    public void setDynamic(Boolean dynamic) {
        this.dynamic = dynamic;
    }

    public DestinationMetadataActionFieldV1 allowNull(Boolean allowNull) {

        this.allowNull = allowNull;
        return this;
    }

    /**
     * Whether this field allows null values.
     *
     * @return allowNull
     */
    @javax.annotation.Nonnull
    public Boolean getAllowNull() {
        return allowNull;
    }

    public void setAllowNull(Boolean allowNull) {
        this.allowNull = allowNull;
    }

    public DestinationMetadataActionFieldV1 hidden(Boolean hidden) {

        this.hidden = hidden;
        return this;
    }

    /**
     * Whether the action field should be hidden or not.
     *
     * @return hidden
     */
    @javax.annotation.Nullable
    public Boolean getHidden() {
        return hidden;
    }

    public void setHidden(Boolean hidden) {
        this.hidden = hidden;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DestinationMetadataActionFieldV1 destinationMetadataActionFieldV1 =
                (DestinationMetadataActionFieldV1) o;
        return Objects.equals(this.id, destinationMetadataActionFieldV1.id)
                && Objects.equals(this.sortOrder, destinationMetadataActionFieldV1.sortOrder)
                && Objects.equals(this.fieldKey, destinationMetadataActionFieldV1.fieldKey)
                && Objects.equals(this.label, destinationMetadataActionFieldV1.label)
                && Objects.equals(this.type, destinationMetadataActionFieldV1.type)
                && Objects.equals(this.description, destinationMetadataActionFieldV1.description)
                && Objects.equals(this.placeholder, destinationMetadataActionFieldV1.placeholder)
                && Objects.equals(this.defaultValue, destinationMetadataActionFieldV1.defaultValue)
                && Objects.equals(this.required, destinationMetadataActionFieldV1.required)
                && Objects.equals(this.multiple, destinationMetadataActionFieldV1.multiple)
                && Objects.equals(this.choices, destinationMetadataActionFieldV1.choices)
                && Objects.equals(this.dynamic, destinationMetadataActionFieldV1.dynamic)
                && Objects.equals(this.allowNull, destinationMetadataActionFieldV1.allowNull)
                && Objects.equals(this.hidden, destinationMetadataActionFieldV1.hidden);
    }

    private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
        return a == b
                || (a != null
                        && b != null
                        && a.isPresent()
                        && b.isPresent()
                        && Objects.deepEquals(a.get(), b.get()));
    }

    @Override
    public int hashCode() {
        return Objects.hash(
                id,
                sortOrder,
                fieldKey,
                label,
                type,
                description,
                placeholder,
                defaultValue,
                required,
                multiple,
                choices,
                dynamic,
                allowNull,
                hidden);
    }

    private static <T> int hashCodeNullable(JsonNullable<T> a) {
        if (a == null) {
            return 1;
        }
        return a.isPresent() ? Arrays.deepHashCode(new Object[] {a.get()}) : 31;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class DestinationMetadataActionFieldV1 {\n");
        sb.append("    id: ").append(toIndentedString(id)).append("\n");
        sb.append("    sortOrder: ").append(toIndentedString(sortOrder)).append("\n");
        sb.append("    fieldKey: ").append(toIndentedString(fieldKey)).append("\n");
        sb.append("    label: ").append(toIndentedString(label)).append("\n");
        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("    description: ").append(toIndentedString(description)).append("\n");
        sb.append("    placeholder: ").append(toIndentedString(placeholder)).append("\n");
        sb.append("    defaultValue: ").append(toIndentedString(defaultValue)).append("\n");
        sb.append("    required: ").append(toIndentedString(required)).append("\n");
        sb.append("    multiple: ").append(toIndentedString(multiple)).append("\n");
        sb.append("    choices: ").append(toIndentedString(choices)).append("\n");
        sb.append("    dynamic: ").append(toIndentedString(dynamic)).append("\n");
        sb.append("    allowNull: ").append(toIndentedString(allowNull)).append("\n");
        sb.append("    hidden: ").append(toIndentedString(hidden)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces (except the first
     * line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

    public static HashSet<String> openapiFields;
    public static HashSet<String> openapiRequiredFields;

    static {
        // a set of all properties/fields (JSON key names)
        openapiFields = new HashSet<String>();
        openapiFields.add("id");
        openapiFields.add("sortOrder");
        openapiFields.add("fieldKey");
        openapiFields.add("label");
        openapiFields.add("type");
        openapiFields.add("description");
        openapiFields.add("placeholder");
        openapiFields.add("defaultValue");
        openapiFields.add("required");
        openapiFields.add("multiple");
        openapiFields.add("choices");
        openapiFields.add("dynamic");
        openapiFields.add("allowNull");
        openapiFields.add("hidden");

        // a set of required properties/fields (JSON key names)
        openapiRequiredFields = new HashSet<String>();
        openapiRequiredFields.add("id");
        openapiRequiredFields.add("sortOrder");
        openapiRequiredFields.add("fieldKey");
        openapiRequiredFields.add("label");
        openapiRequiredFields.add("type");
        openapiRequiredFields.add("description");
        openapiRequiredFields.add("required");
        openapiRequiredFields.add("multiple");
        openapiRequiredFields.add("dynamic");
        openapiRequiredFields.add("allowNull");
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to
     *     DestinationMetadataActionFieldV1
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        if (jsonElement == null) {
            if (!DestinationMetadataActionFieldV1.openapiRequiredFields
                    .isEmpty()) { // has required fields but JSON element is null
                throw new IllegalArgumentException(
                        String.format(
                                "The required field(s) %s in DestinationMetadataActionFieldV1 is"
                                        + " not found in the empty JSON string",
                                DestinationMetadataActionFieldV1.openapiRequiredFields.toString()));
            }
        }

        Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
        // check to see if the JSON string contains additional fields
        for (Map.Entry<String, JsonElement> entry : entries) {
            if (!DestinationMetadataActionFieldV1.openapiFields.contains(entry.getKey())) {
                throw new IllegalArgumentException(
                        String.format(
                                "The field `%s` in the JSON string is not defined in the"
                                    + " `DestinationMetadataActionFieldV1` properties. JSON: %s",
                                entry.getKey(), jsonElement.toString()));
            }
        }

        // check to make sure all required properties/fields are present in the JSON string
        for (String requiredField : DestinationMetadataActionFieldV1.openapiRequiredFields) {
            if (jsonElement.getAsJsonObject().get(requiredField) == null) {
                throw new IllegalArgumentException(
                        String.format(
                                "The required field `%s` is not found in the JSON string: %s",
                                requiredField, jsonElement.toString()));
            }
        }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
        if (!jsonObj.get("id").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `id` to be a primitive type in the JSON string but"
                                    + " got `%s`",
                            jsonObj.get("id").toString()));
        }
        if (!jsonObj.get("fieldKey").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `fieldKey` to be a primitive type in the JSON"
                                    + " string but got `%s`",
                            jsonObj.get("fieldKey").toString()));
        }
        if (!jsonObj.get("label").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `label` to be a primitive type in the JSON string"
                                    + " but got `%s`",
                            jsonObj.get("label").toString()));
        }
        if (!jsonObj.get("type").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `type` to be a primitive type in the JSON string"
                                    + " but got `%s`",
                            jsonObj.get("type").toString()));
        }
        if (!jsonObj.get("description").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `description` to be a primitive type in the JSON"
                                    + " string but got `%s`",
                            jsonObj.get("description").toString()));
        }
        if ((jsonObj.get("placeholder") != null && !jsonObj.get("placeholder").isJsonNull())
                && !jsonObj.get("placeholder").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `placeholder` to be a primitive type in the JSON"
                                    + " string but got `%s`",
                            jsonObj.get("placeholder").toString()));
        }
    }

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!DestinationMetadataActionFieldV1.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'DestinationMetadataActionFieldV1' and
                // its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<DestinationMetadataActionFieldV1> thisAdapter =
                    gson.getDelegateAdapter(
                            this, TypeToken.get(DestinationMetadataActionFieldV1.class));

            return (TypeAdapter<T>)
                    new TypeAdapter<DestinationMetadataActionFieldV1>() {
                        @Override
                        public void write(JsonWriter out, DestinationMetadataActionFieldV1 value)
                                throws IOException {
                            JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
                            elementAdapter.write(out, obj);
                        }

                        @Override
                        public DestinationMetadataActionFieldV1 read(JsonReader in)
                                throws IOException {
                            JsonElement jsonElement = elementAdapter.read(in);
                            validateJsonElement(jsonElement);
                            return thisAdapter.fromJsonTree(jsonElement);
                        }
                    }.nullSafe();
        }
    }

    /**
     * Create an instance of DestinationMetadataActionFieldV1 given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of DestinationMetadataActionFieldV1
     * @throws IOException if the JSON string is invalid with respect to
     *     DestinationMetadataActionFieldV1
     */
    public static DestinationMetadataActionFieldV1 fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, DestinationMetadataActionFieldV1.class);
    }

    /**
     * Convert an instance of DestinationMetadataActionFieldV1 to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}
