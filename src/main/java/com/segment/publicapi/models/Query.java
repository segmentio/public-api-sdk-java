/*
 * Segment Public API
 * The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.
 *
 * Contact: friends@segment.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.segment.publicapi.models;


import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.segment.publicapi.JSON;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;

/** Input query returned */
@ApiModel(description = "Input query returned")
public class Query {
    public static final String SERIALIZED_NAME_WORKSPACE_ID = "workspaceId";

    @SerializedName(SERIALIZED_NAME_WORKSPACE_ID)
    private String workspaceId;

    /** Granularity corresponds to the requested bucket granularity */
    @JsonAdapter(GranularityEnum.Adapter.class)
    public enum GranularityEnum {
        DAY("day"),

        HOUR("hour"),

        MINUTE("minute");

        private String value;

        GranularityEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static GranularityEnum fromValue(String value) {
            for (GranularityEnum b : GranularityEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }

        public static class Adapter extends TypeAdapter<GranularityEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final GranularityEnum enumeration)
                    throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public GranularityEnum read(final JsonReader jsonReader) throws IOException {
                String value = jsonReader.nextString();
                return GranularityEnum.fromValue(value);
            }
        }
    }

    public static final String SERIALIZED_NAME_GRANULARITY = "granularity";

    @SerializedName(SERIALIZED_NAME_GRANULARITY)
    private GranularityEnum granularity;

    public static final String SERIALIZED_NAME_START_TIME = "startTime";

    @SerializedName(SERIALIZED_NAME_START_TIME)
    private String startTime;

    public static final String SERIALIZED_NAME_END_TIME = "endTime";

    @SerializedName(SERIALIZED_NAME_END_TIME)
    private String endTime;

    public static final String SERIALIZED_NAME_GROUP_BY = "groupBy";

    @SerializedName(SERIALIZED_NAME_GROUP_BY)
    private List<String> groupBy = null;

    public static final String SERIALIZED_NAME_SOURCE_ID = "sourceId";

    @SerializedName(SERIALIZED_NAME_SOURCE_ID)
    private List<String> sourceId = null;

    public static final String SERIALIZED_NAME_EVENT_NAME = "eventName";

    @SerializedName(SERIALIZED_NAME_EVENT_NAME)
    private List<String> eventName = null;

    public static final String SERIALIZED_NAME_EVENT_TYPE = "eventType";

    @SerializedName(SERIALIZED_NAME_EVENT_TYPE)
    private List<String> eventType = null;

    public static final String SERIALIZED_NAME_APP_VERSION = "appVersion";

    @SerializedName(SERIALIZED_NAME_APP_VERSION)
    private List<String> appVersion = null;

    public static final String SERIALIZED_NAME_LIMIT = "limit";

    @SerializedName(SERIALIZED_NAME_LIMIT)
    private BigDecimal limit;

    public Query() {}

    public Query workspaceId(String workspaceId) {

        this.workspaceId = workspaceId;
        return this;
    }

    /**
     * workspaceId corresponds to the workspace being requested.
     *
     * @return workspaceId
     */
    @javax.annotation.Nonnull
    @ApiModelProperty(
            required = true,
            value = "workspaceId corresponds to the workspace being requested.")
    public String getWorkspaceId() {
        return workspaceId;
    }

    public void setWorkspaceId(String workspaceId) {
        this.workspaceId = workspaceId;
    }

    public Query granularity(GranularityEnum granularity) {

        this.granularity = granularity;
        return this;
    }

    /**
     * Granularity corresponds to the requested bucket granularity
     *
     * @return granularity
     */
    @javax.annotation.Nonnull
    @ApiModelProperty(
            required = true,
            value = "Granularity corresponds to the requested bucket granularity")
    public GranularityEnum getGranularity() {
        return granularity;
    }

    public void setGranularity(GranularityEnum granularity) {
        this.granularity = granularity;
    }

    public Query startTime(String startTime) {

        this.startTime = startTime;
        return this;
    }

    /**
     * StartTime is the ISO8601 formatted timestamp corresponding to the beginning of the requested
     * timeframe, inclusive.
     *
     * @return startTime
     */
    @javax.annotation.Nonnull
    @ApiModelProperty(
            required = true,
            value =
                    "StartTime is the ISO8601 formatted timestamp corresponding to the beginning of"
                            + " the requested timeframe, inclusive.")
    public String getStartTime() {
        return startTime;
    }

    public void setStartTime(String startTime) {
        this.startTime = startTime;
    }

    public Query endTime(String endTime) {

        this.endTime = endTime;
        return this;
    }

    /**
     * EndTime is the ISO8601 formatted timestamp corresponding to the end of the requested
     * timeframe, noninclusive.
     *
     * @return endTime
     */
    @javax.annotation.Nonnull
    @ApiModelProperty(
            required = true,
            value =
                    "EndTime is the ISO8601 formatted timestamp corresponding to the end of the"
                            + " requested timeframe, noninclusive.")
    public String getEndTime() {
        return endTime;
    }

    public void setEndTime(String endTime) {
        this.endTime = endTime;
    }

    public Query groupBy(List<String> groupBy) {

        this.groupBy = groupBy;
        return this;
    }

    public Query addGroupByItem(String groupByItem) {
        if (this.groupBy == null) {
            this.groupBy = new ArrayList<>();
        }
        this.groupBy.add(groupByItem);
        return this;
    }

    /**
     * GroupBy is a comma-delimited list of strings representing the dimensions to group the result
     * by. The current options are: &#x60;eventName&#x60; or &#x60;eventType&#x60;
     *
     * @return groupBy
     */
    @javax.annotation.Nullable
    @ApiModelProperty(
            value =
                    "GroupBy is a comma-delimited list of strings representing the dimensions to"
                            + " group the result by. The current options are: `eventName` or"
                            + " `eventType`")
    public List<String> getGroupBy() {
        return groupBy;
    }

    public void setGroupBy(List<String> groupBy) {
        this.groupBy = groupBy;
    }

    public Query sourceId(List<String> sourceId) {

        this.sourceId = sourceId;
        return this;
    }

    public Query addSourceIdItem(String sourceIdItem) {
        if (this.sourceId == null) {
            this.sourceId = new ArrayList<>();
        }
        this.sourceId.add(sourceIdItem);
        return this;
    }

    /**
     * SourceId is a list of strings which allow you to restrict the result to just the given
     * sourceIds.
     *
     * @return sourceId
     */
    @javax.annotation.Nullable
    @ApiModelProperty(
            value =
                    "SourceId is a list of strings which allow you to restrict the result to just"
                            + " the given sourceIds.")
    public List<String> getSourceId() {
        return sourceId;
    }

    public void setSourceId(List<String> sourceId) {
        this.sourceId = sourceId;
    }

    public Query eventName(List<String> eventName) {

        this.eventName = eventName;
        return this;
    }

    public Query addEventNameItem(String eventNameItem) {
        if (this.eventName == null) {
            this.eventName = new ArrayList<>();
        }
        this.eventName.add(eventNameItem);
        return this;
    }

    /**
     * EventName is a list of strings which allow you to restrict the result to just the given
     * eventNames.
     *
     * @return eventName
     */
    @javax.annotation.Nullable
    @ApiModelProperty(
            value =
                    "EventName is a list of strings which allow you to restrict the result to just"
                            + " the given eventNames.")
    public List<String> getEventName() {
        return eventName;
    }

    public void setEventName(List<String> eventName) {
        this.eventName = eventName;
    }

    public Query eventType(List<String> eventType) {

        this.eventType = eventType;
        return this;
    }

    public Query addEventTypeItem(String eventTypeItem) {
        if (this.eventType == null) {
            this.eventType = new ArrayList<>();
        }
        this.eventType.add(eventTypeItem);
        return this;
    }

    /**
     * EventType is a list of strings which allow you to restrict the result to just the given
     * eventTypes.
     *
     * @return eventType
     */
    @javax.annotation.Nullable
    @ApiModelProperty(
            value =
                    "EventType is a list of strings which allow you to restrict the result to just"
                            + " the given eventTypes.")
    public List<String> getEventType() {
        return eventType;
    }

    public void setEventType(List<String> eventType) {
        this.eventType = eventType;
    }

    public Query appVersion(List<String> appVersion) {

        this.appVersion = appVersion;
        return this;
    }

    public Query addAppVersionItem(String appVersionItem) {
        if (this.appVersion == null) {
            this.appVersion = new ArrayList<>();
        }
        this.appVersion.add(appVersionItem);
        return this;
    }

    /**
     * AppVersion is a list of strings which allow you to restrict the result to just the given
     * appVersions.
     *
     * @return appVersion
     */
    @javax.annotation.Nullable
    @ApiModelProperty(
            value =
                    "AppVersion is a list of strings which allow you to restrict the result to just"
                            + " the given appVersions.")
    public List<String> getAppVersion() {
        return appVersion;
    }

    public void setAppVersion(List<String> appVersion) {
        this.appVersion = appVersion;
    }

    public Query limit(BigDecimal limit) {

        this.limit = limit;
        return this;
    }

    /**
     * Limit is the total number of items in the result
     *
     * @return limit
     */
    @javax.annotation.Nullable
    @ApiModelProperty(value = "Limit is the total number of items in the result")
    public BigDecimal getLimit() {
        return limit;
    }

    public void setLimit(BigDecimal limit) {
        this.limit = limit;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Query query = (Query) o;
        return Objects.equals(this.workspaceId, query.workspaceId)
                && Objects.equals(this.granularity, query.granularity)
                && Objects.equals(this.startTime, query.startTime)
                && Objects.equals(this.endTime, query.endTime)
                && Objects.equals(this.groupBy, query.groupBy)
                && Objects.equals(this.sourceId, query.sourceId)
                && Objects.equals(this.eventName, query.eventName)
                && Objects.equals(this.eventType, query.eventType)
                && Objects.equals(this.appVersion, query.appVersion)
                && Objects.equals(this.limit, query.limit);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
                workspaceId,
                granularity,
                startTime,
                endTime,
                groupBy,
                sourceId,
                eventName,
                eventType,
                appVersion,
                limit);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class Query {\n");
        sb.append("    workspaceId: ").append(toIndentedString(workspaceId)).append("\n");
        sb.append("    granularity: ").append(toIndentedString(granularity)).append("\n");
        sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
        sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
        sb.append("    groupBy: ").append(toIndentedString(groupBy)).append("\n");
        sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
        sb.append("    eventName: ").append(toIndentedString(eventName)).append("\n");
        sb.append("    eventType: ").append(toIndentedString(eventType)).append("\n");
        sb.append("    appVersion: ").append(toIndentedString(appVersion)).append("\n");
        sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces (except the first
     * line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

    public static HashSet<String> openapiFields;
    public static HashSet<String> openapiRequiredFields;

    static {
        // a set of all properties/fields (JSON key names)
        openapiFields = new HashSet<String>();
        openapiFields.add("workspaceId");
        openapiFields.add("granularity");
        openapiFields.add("startTime");
        openapiFields.add("endTime");
        openapiFields.add("groupBy");
        openapiFields.add("sourceId");
        openapiFields.add("eventName");
        openapiFields.add("eventType");
        openapiFields.add("appVersion");
        openapiFields.add("limit");

        // a set of required properties/fields (JSON key names)
        openapiRequiredFields = new HashSet<String>();
        openapiRequiredFields.add("workspaceId");
        openapiRequiredFields.add("granularity");
        openapiRequiredFields.add("startTime");
        openapiRequiredFields.add("endTime");
    }

    /**
     * Validates the JSON Object and throws an exception if issues found
     *
     * @param jsonObj JSON Object
     * @throws IOException if the JSON Object is invalid with respect to Query
     */
    public static void validateJsonObject(JsonObject jsonObj) throws IOException {
        if (jsonObj == null) {
            if (!Query.openapiRequiredFields
                    .isEmpty()) { // has required fields but JSON object is null
                throw new IllegalArgumentException(
                        String.format(
                                "The required field(s) %s in Query is not found in the empty JSON"
                                        + " string",
                                Query.openapiRequiredFields.toString()));
            }
        }

        Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
        // check to see if the JSON string contains additional fields
        for (Entry<String, JsonElement> entry : entries) {
            if (!Query.openapiFields.contains(entry.getKey())) {
                throw new IllegalArgumentException(
                        String.format(
                                "The field `%s` in the JSON string is not defined in the `Query`"
                                        + " properties. JSON: %s",
                                entry.getKey(), jsonObj.toString()));
            }
        }

        // check to make sure all required properties/fields are present in the JSON string
        for (String requiredField : Query.openapiRequiredFields) {
            if (jsonObj.get(requiredField) == null) {
                throw new IllegalArgumentException(
                        String.format(
                                "The required field `%s` is not found in the JSON string: %s",
                                requiredField, jsonObj.toString()));
            }
        }
        if (!jsonObj.get("workspaceId").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `workspaceId` to be a primitive type in the JSON"
                                    + " string but got `%s`",
                            jsonObj.get("workspaceId").toString()));
        }
        if (!jsonObj.get("granularity").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `granularity` to be a primitive type in the JSON"
                                    + " string but got `%s`",
                            jsonObj.get("granularity").toString()));
        }
        if (!jsonObj.get("startTime").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `startTime` to be a primitive type in the JSON"
                                    + " string but got `%s`",
                            jsonObj.get("startTime").toString()));
        }
        if (!jsonObj.get("endTime").isJsonPrimitive()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `endTime` to be a primitive type in the JSON string"
                                    + " but got `%s`",
                            jsonObj.get("endTime").toString()));
        }
        // ensure the optional json data is an array if present
        if (jsonObj.get("groupBy") != null && !jsonObj.get("groupBy").isJsonArray()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `groupBy` to be an array in the JSON string but got"
                                    + " `%s`",
                            jsonObj.get("groupBy").toString()));
        }
        // ensure the optional json data is an array if present
        if (jsonObj.get("sourceId") != null && !jsonObj.get("sourceId").isJsonArray()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `sourceId` to be an array in the JSON string but"
                                    + " got `%s`",
                            jsonObj.get("sourceId").toString()));
        }
        // ensure the optional json data is an array if present
        if (jsonObj.get("eventName") != null && !jsonObj.get("eventName").isJsonArray()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `eventName` to be an array in the JSON string but"
                                    + " got `%s`",
                            jsonObj.get("eventName").toString()));
        }
        // ensure the optional json data is an array if present
        if (jsonObj.get("eventType") != null && !jsonObj.get("eventType").isJsonArray()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `eventType` to be an array in the JSON string but"
                                    + " got `%s`",
                            jsonObj.get("eventType").toString()));
        }
        // ensure the optional json data is an array if present
        if (jsonObj.get("appVersion") != null && !jsonObj.get("appVersion").isJsonArray()) {
            throw new IllegalArgumentException(
                    String.format(
                            "Expected the field `appVersion` to be an array in the JSON string but"
                                    + " got `%s`",
                            jsonObj.get("appVersion").toString()));
        }
    }

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!Query.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'Query' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<Query> thisAdapter =
                    gson.getDelegateAdapter(this, TypeToken.get(Query.class));

            return (TypeAdapter<T>)
                    new TypeAdapter<Query>() {
                        @Override
                        public void write(JsonWriter out, Query value) throws IOException {
                            JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
                            elementAdapter.write(out, obj);
                        }

                        @Override
                        public Query read(JsonReader in) throws IOException {
                            JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
                            validateJsonObject(jsonObj);
                            return thisAdapter.fromJsonTree(jsonObj);
                        }
                    }.nullSafe();
        }
    }

    /**
     * Create an instance of Query given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of Query
     * @throws IOException if the JSON string is invalid with respect to Query
     */
    public static Query fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, Query.class);
    }

    /**
     * Convert an instance of Query to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}
