/*
 * Segment Public API
 * The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.
 *
 * Contact: friends@segment.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.segment.publicapi.api;

import com.google.gson.reflect.TypeToken;
import com.segment.publicapi.ApiCallback;
import com.segment.publicapi.ApiClient;
import com.segment.publicapi.ApiException;
import com.segment.publicapi.ApiResponse;
import com.segment.publicapi.Configuration;
import com.segment.publicapi.Pair;
import com.segment.publicapi.models.CreateCloudSourceRegulation200Response;
import com.segment.publicapi.models.CreateCloudSourceRegulationV1Input;
import com.segment.publicapi.models.CreateSourceRegulation200Response;
import com.segment.publicapi.models.CreateSourceRegulationV1Input;
import com.segment.publicapi.models.CreateWorkspaceRegulation200Response;
import com.segment.publicapi.models.CreateWorkspaceRegulationV1Input;
import com.segment.publicapi.models.DeleteRegulation200Response;
import com.segment.publicapi.models.GetRegulation200Response;
import com.segment.publicapi.models.ListRegulationsFromSource200Response;
import com.segment.publicapi.models.ListSuppressions200Response;
import com.segment.publicapi.models.ListWorkspaceRegulations200Response;
import com.segment.publicapi.models.PaginationInput;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DeletionAndSuppressionApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DeletionAndSuppressionApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DeletionAndSuppressionApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createCloudSourceRegulation
     *
     * @param sourceId (required)
     * @param createCloudSourceRegulationV1Input (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createCloudSourceRegulationCall(
            String sourceId,
            CreateCloudSourceRegulationV1Input createCloudSourceRegulationV1Input,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createCloudSourceRegulationV1Input;

        // create path and map variables
        String localVarPath =
                "/regulations/cloudsources/{sourceId}"
                        .replace(
                                "{" + "sourceId" + "}",
                                localVarApiClient.escapeString(sourceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "application/vnd.segment.v1+json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCloudSourceRegulationValidateBeforeCall(
            String sourceId,
            CreateCloudSourceRegulationV1Input createCloudSourceRegulationV1Input,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'sourceId' is set
        if (sourceId == null) {
            throw new ApiException(
                    "Missing the required parameter 'sourceId' when calling"
                            + " createCloudSourceRegulation(Async)");
        }

        // verify the required parameter 'createCloudSourceRegulationV1Input' is set
        if (createCloudSourceRegulationV1Input == null) {
            throw new ApiException(
                    "Missing the required parameter 'createCloudSourceRegulationV1Input' when"
                            + " calling createCloudSourceRegulation(Async)");
        }

        return createCloudSourceRegulationCall(
                sourceId, createCloudSourceRegulationV1Input, _callback);
    }

    /**
     * Create Cloud Source Regulation Creates a Source-scoped regulation. Please Note: Suppression
     * rules at the Workspace level take precedence over those at the Source level. If a user has
     * been suppressed at the Workspace level, any attempt to un-suppress at the Source level is not
     * supported and the processing of the request will fail in Segment Config API omitted fields: -
     * &#x60;attributes&#x60;, - &#x60;userAgent&#x60; Rate limit headers will be updated to reflect
     * regulation-specific limits (tracked separately for Segment-only vs Segment &amp; Destination
     * regulation types): - X-RateLimit-Remaining: Remaining requests for the regulation type
     * category - Segment-only Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL,
     * SUPPRESS_ONLY, UNSUPPRESS, DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations:
     * DELETE_ONLY, SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota
     * resets (for example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param sourceId (required)
     * @param createCloudSourceRegulationV1Input (required)
     * @return CreateCloudSourceRegulation200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public CreateCloudSourceRegulation200Response createCloudSourceRegulation(
            String sourceId, CreateCloudSourceRegulationV1Input createCloudSourceRegulationV1Input)
            throws ApiException {
        ApiResponse<CreateCloudSourceRegulation200Response> localVarResp =
                createCloudSourceRegulationWithHttpInfo(
                        sourceId, createCloudSourceRegulationV1Input);
        return localVarResp.getData();
    }

    /**
     * Create Cloud Source Regulation Creates a Source-scoped regulation. Please Note: Suppression
     * rules at the Workspace level take precedence over those at the Source level. If a user has
     * been suppressed at the Workspace level, any attempt to un-suppress at the Source level is not
     * supported and the processing of the request will fail in Segment Config API omitted fields: -
     * &#x60;attributes&#x60;, - &#x60;userAgent&#x60; Rate limit headers will be updated to reflect
     * regulation-specific limits (tracked separately for Segment-only vs Segment &amp; Destination
     * regulation types): - X-RateLimit-Remaining: Remaining requests for the regulation type
     * category - Segment-only Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL,
     * SUPPRESS_ONLY, UNSUPPRESS, DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations:
     * DELETE_ONLY, SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota
     * resets (for example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param sourceId (required)
     * @param createCloudSourceRegulationV1Input (required)
     * @return ApiResponse&lt;CreateCloudSourceRegulation200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CreateCloudSourceRegulation200Response>
            createCloudSourceRegulationWithHttpInfo(
                    String sourceId,
                    CreateCloudSourceRegulationV1Input createCloudSourceRegulationV1Input)
                    throws ApiException {
        okhttp3.Call localVarCall =
                createCloudSourceRegulationValidateBeforeCall(
                        sourceId, createCloudSourceRegulationV1Input, null);
        Type localVarReturnType =
                new TypeToken<CreateCloudSourceRegulation200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Cloud Source Regulation (asynchronously) Creates a Source-scoped regulation. Please
     * Note: Suppression rules at the Workspace level take precedence over those at the Source
     * level. If a user has been suppressed at the Workspace level, any attempt to un-suppress at
     * the Source level is not supported and the processing of the request will fail in Segment
     * Config API omitted fields: - &#x60;attributes&#x60;, - &#x60;userAgent&#x60; Rate limit
     * headers will be updated to reflect regulation-specific limits (tracked separately for
     * Segment-only vs Segment &amp; Destination regulation types): - X-RateLimit-Remaining:
     * Remaining requests for the regulation type category - Segment-only Regulations:
     * DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param sourceId (required)
     * @param createCloudSourceRegulationV1Input (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createCloudSourceRegulationAsync(
            String sourceId,
            CreateCloudSourceRegulationV1Input createCloudSourceRegulationV1Input,
            final ApiCallback<CreateCloudSourceRegulation200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createCloudSourceRegulationValidateBeforeCall(
                        sourceId, createCloudSourceRegulationV1Input, _callback);
        Type localVarReturnType =
                new TypeToken<CreateCloudSourceRegulation200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for createSourceRegulation
     *
     * @param sourceId (required)
     * @param createSourceRegulationV1Input (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createSourceRegulationCall(
            String sourceId,
            CreateSourceRegulationV1Input createSourceRegulationV1Input,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createSourceRegulationV1Input;

        // create path and map variables
        String localVarPath =
                "/regulations/sources/{sourceId}"
                        .replace(
                                "{" + "sourceId" + "}",
                                localVarApiClient.escapeString(sourceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "application/vnd.segment.v1+json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSourceRegulationValidateBeforeCall(
            String sourceId,
            CreateSourceRegulationV1Input createSourceRegulationV1Input,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'sourceId' is set
        if (sourceId == null) {
            throw new ApiException(
                    "Missing the required parameter 'sourceId' when calling"
                            + " createSourceRegulation(Async)");
        }

        // verify the required parameter 'createSourceRegulationV1Input' is set
        if (createSourceRegulationV1Input == null) {
            throw new ApiException(
                    "Missing the required parameter 'createSourceRegulationV1Input' when calling"
                            + " createSourceRegulation(Async)");
        }

        return createSourceRegulationCall(sourceId, createSourceRegulationV1Input, _callback);
    }

    /**
     * Create Source Regulation Creates a Source-scoped regulation. Please Note: Suppression rules
     * at the Workspace level take precedence over those at the Source level. If a user has been
     * suppressed at the Workspace level, any attempt to un-suppress at the Source level is not
     * supported and the processing of the request will fail in Segment • When called, this endpoint
     * may generate the &#x60;Source Regulation Created&#x60; event in the [audit
     * trail](/tag/Audit-Trail). Config API omitted fields: - &#x60;attributes&#x60;, -
     * &#x60;userAgent&#x60; Rate limit headers will be updated to reflect regulation-specific
     * limits (tracked separately for Segment-only vs Segment &amp; Destination regulation types): -
     * X-RateLimit-Remaining: Remaining requests for the regulation type category - Segment-only
     * Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param sourceId (required)
     * @param createSourceRegulationV1Input (required)
     * @return CreateSourceRegulation200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public CreateSourceRegulation200Response createSourceRegulation(
            String sourceId, CreateSourceRegulationV1Input createSourceRegulationV1Input)
            throws ApiException {
        ApiResponse<CreateSourceRegulation200Response> localVarResp =
                createSourceRegulationWithHttpInfo(sourceId, createSourceRegulationV1Input);
        return localVarResp.getData();
    }

    /**
     * Create Source Regulation Creates a Source-scoped regulation. Please Note: Suppression rules
     * at the Workspace level take precedence over those at the Source level. If a user has been
     * suppressed at the Workspace level, any attempt to un-suppress at the Source level is not
     * supported and the processing of the request will fail in Segment • When called, this endpoint
     * may generate the &#x60;Source Regulation Created&#x60; event in the [audit
     * trail](/tag/Audit-Trail). Config API omitted fields: - &#x60;attributes&#x60;, -
     * &#x60;userAgent&#x60; Rate limit headers will be updated to reflect regulation-specific
     * limits (tracked separately for Segment-only vs Segment &amp; Destination regulation types): -
     * X-RateLimit-Remaining: Remaining requests for the regulation type category - Segment-only
     * Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param sourceId (required)
     * @param createSourceRegulationV1Input (required)
     * @return ApiResponse&lt;CreateSourceRegulation200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CreateSourceRegulation200Response> createSourceRegulationWithHttpInfo(
            String sourceId, CreateSourceRegulationV1Input createSourceRegulationV1Input)
            throws ApiException {
        okhttp3.Call localVarCall =
                createSourceRegulationValidateBeforeCall(
                        sourceId, createSourceRegulationV1Input, null);
        Type localVarReturnType = new TypeToken<CreateSourceRegulation200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Source Regulation (asynchronously) Creates a Source-scoped regulation. Please Note:
     * Suppression rules at the Workspace level take precedence over those at the Source level. If a
     * user has been suppressed at the Workspace level, any attempt to un-suppress at the Source
     * level is not supported and the processing of the request will fail in Segment • When called,
     * this endpoint may generate the &#x60;Source Regulation Created&#x60; event in the [audit
     * trail](/tag/Audit-Trail). Config API omitted fields: - &#x60;attributes&#x60;, -
     * &#x60;userAgent&#x60; Rate limit headers will be updated to reflect regulation-specific
     * limits (tracked separately for Segment-only vs Segment &amp; Destination regulation types): -
     * X-RateLimit-Remaining: Remaining requests for the regulation type category - Segment-only
     * Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param sourceId (required)
     * @param createSourceRegulationV1Input (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createSourceRegulationAsync(
            String sourceId,
            CreateSourceRegulationV1Input createSourceRegulationV1Input,
            final ApiCallback<CreateSourceRegulation200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createSourceRegulationValidateBeforeCall(
                        sourceId, createSourceRegulationV1Input, _callback);
        Type localVarReturnType = new TypeToken<CreateSourceRegulation200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for createWorkspaceRegulation
     *
     * @param createWorkspaceRegulationV1Input (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createWorkspaceRegulationCall(
            CreateWorkspaceRegulationV1Input createWorkspaceRegulationV1Input,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createWorkspaceRegulationV1Input;

        // create path and map variables
        String localVarPath = "/regulations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "application/vnd.segment.v1+json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createWorkspaceRegulationValidateBeforeCall(
            CreateWorkspaceRegulationV1Input createWorkspaceRegulationV1Input,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createWorkspaceRegulationV1Input' is set
        if (createWorkspaceRegulationV1Input == null) {
            throw new ApiException(
                    "Missing the required parameter 'createWorkspaceRegulationV1Input' when calling"
                            + " createWorkspaceRegulation(Async)");
        }

        return createWorkspaceRegulationCall(createWorkspaceRegulationV1Input, _callback);
    }

    /**
     * Create Workspace Regulation Creates a Workspace-scoped regulation. • When called, this
     * endpoint may generate the &#x60;Workspace Regulation Created&#x60; event in the [audit
     * trail](/tag/Audit-Trail). Config API omitted fields: - &#x60;attributes&#x60;, -
     * &#x60;userAgent&#x60; Rate limit headers will be updated to reflect regulation-specific
     * limits (tracked separately for Segment-only vs Segment &amp; Destination regulation types): -
     * X-RateLimit-Remaining: Remaining requests for the regulation type category - Segment-only
     * Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param createWorkspaceRegulationV1Input (required)
     * @return CreateWorkspaceRegulation200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public CreateWorkspaceRegulation200Response createWorkspaceRegulation(
            CreateWorkspaceRegulationV1Input createWorkspaceRegulationV1Input) throws ApiException {
        ApiResponse<CreateWorkspaceRegulation200Response> localVarResp =
                createWorkspaceRegulationWithHttpInfo(createWorkspaceRegulationV1Input);
        return localVarResp.getData();
    }

    /**
     * Create Workspace Regulation Creates a Workspace-scoped regulation. • When called, this
     * endpoint may generate the &#x60;Workspace Regulation Created&#x60; event in the [audit
     * trail](/tag/Audit-Trail). Config API omitted fields: - &#x60;attributes&#x60;, -
     * &#x60;userAgent&#x60; Rate limit headers will be updated to reflect regulation-specific
     * limits (tracked separately for Segment-only vs Segment &amp; Destination regulation types): -
     * X-RateLimit-Remaining: Remaining requests for the regulation type category - Segment-only
     * Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param createWorkspaceRegulationV1Input (required)
     * @return ApiResponse&lt;CreateWorkspaceRegulation200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CreateWorkspaceRegulation200Response> createWorkspaceRegulationWithHttpInfo(
            CreateWorkspaceRegulationV1Input createWorkspaceRegulationV1Input) throws ApiException {
        okhttp3.Call localVarCall =
                createWorkspaceRegulationValidateBeforeCall(createWorkspaceRegulationV1Input, null);
        Type localVarReturnType =
                new TypeToken<CreateWorkspaceRegulation200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Workspace Regulation (asynchronously) Creates a Workspace-scoped regulation. • When
     * called, this endpoint may generate the &#x60;Workspace Regulation Created&#x60; event in the
     * [audit trail](/tag/Audit-Trail). Config API omitted fields: - &#x60;attributes&#x60;, -
     * &#x60;userAgent&#x60; Rate limit headers will be updated to reflect regulation-specific
     * limits (tracked separately for Segment-only vs Segment &amp; Destination regulation types): -
     * X-RateLimit-Remaining: Remaining requests for the regulation type category - Segment-only
     * Regulations: DELETE_INTERNAL, SUPPRESS_WITH_DELETE_INTERNAL, SUPPRESS_ONLY, UNSUPPRESS,
     * DELETE_ARCHIVE_ONLY - Segment &amp; Destination Regulations: DELETE_ONLY,
     * SUPPRESS_WITH_DELETE - X-RateLimit-Reset: RFC 5322 timestamp for when the quota resets (for
     * example, Tue, 31 Dec 2024 23:59:59 GMT)
     *
     * @param createWorkspaceRegulationV1Input (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  * X-RateLimit-Remaining - Remaining requests in the current period for the regulation type category. Tracked separately for Segment-only vs Segment &amp; Destination regulation types. <br>  * X-RateLimit-Reset - RFC 5322 timestamp indicating when the regulation quota resets for the specific regulation type category. <br>  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createWorkspaceRegulationAsync(
            CreateWorkspaceRegulationV1Input createWorkspaceRegulationV1Input,
            final ApiCallback<CreateWorkspaceRegulation200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createWorkspaceRegulationValidateBeforeCall(
                        createWorkspaceRegulationV1Input, _callback);
        Type localVarReturnType =
                new TypeToken<CreateWorkspaceRegulation200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for deleteRegulation
     *
     * @param regulateId (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call deleteRegulationCall(String regulateId, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/regulations/{regulateId}"
                        .replace(
                                "{" + "regulateId" + "}",
                                localVarApiClient.escapeString(regulateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteRegulationValidateBeforeCall(
            String regulateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'regulateId' is set
        if (regulateId == null) {
            throw new ApiException(
                    "Missing the required parameter 'regulateId' when calling"
                            + " deleteRegulation(Async)");
        }

        return deleteRegulationCall(regulateId, _callback);
    }

    /**
     * Delete Regulation Deletes a regulation from the Workspace. The regulation must be in the
     * initialized state to be deleted. • When called, this endpoint may generate the
     * &#x60;Regulation Deleted&#x60; event in the [audit trail](/tag/Audit-Trail). **DEPRECATED**:
     * this endpoint has been deprecated according to the guidelines, and may experience reduced SLA
     * guarantees.
     *
     * @param regulateId (required)
     * @return DeleteRegulation200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public DeleteRegulation200Response deleteRegulation(String regulateId) throws ApiException {
        ApiResponse<DeleteRegulation200Response> localVarResp =
                deleteRegulationWithHttpInfo(regulateId);
        return localVarResp.getData();
    }

    /**
     * Delete Regulation Deletes a regulation from the Workspace. The regulation must be in the
     * initialized state to be deleted. • When called, this endpoint may generate the
     * &#x60;Regulation Deleted&#x60; event in the [audit trail](/tag/Audit-Trail). **DEPRECATED**:
     * this endpoint has been deprecated according to the guidelines, and may experience reduced SLA
     * guarantees.
     *
     * @param regulateId (required)
     * @return ApiResponse&lt;DeleteRegulation200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public ApiResponse<DeleteRegulation200Response> deleteRegulationWithHttpInfo(String regulateId)
            throws ApiException {
        okhttp3.Call localVarCall = deleteRegulationValidateBeforeCall(regulateId, null);
        Type localVarReturnType = new TypeToken<DeleteRegulation200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Regulation (asynchronously) Deletes a regulation from the Workspace. The regulation
     * must be in the initialized state to be deleted. • When called, this endpoint may generate the
     * &#x60;Regulation Deleted&#x60; event in the [audit trail](/tag/Audit-Trail). **DEPRECATED**:
     * this endpoint has been deprecated according to the guidelines, and may experience reduced SLA
     * guarantees.
     *
     * @param regulateId (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call deleteRegulationAsync(
            String regulateId, final ApiCallback<DeleteRegulation200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteRegulationValidateBeforeCall(regulateId, _callback);
        Type localVarReturnType = new TypeToken<DeleteRegulation200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getRegulation
     *
     * @param regulateId (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getRegulationCall(String regulateId, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/regulations/{regulateId}"
                        .replace(
                                "{" + "regulateId" + "}",
                                localVarApiClient.escapeString(regulateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRegulationValidateBeforeCall(
            String regulateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'regulateId' is set
        if (regulateId == null) {
            throw new ApiException(
                    "Missing the required parameter 'regulateId' when calling"
                            + " getRegulation(Async)");
        }

        return getRegulationCall(regulateId, _callback);
    }

    /**
     * Get Regulation Gets a regulation from the Workspace. Config API omitted fields: -
     * &#x60;parent&#x60;
     *
     * @param regulateId (required)
     * @return GetRegulation200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public GetRegulation200Response getRegulation(String regulateId) throws ApiException {
        ApiResponse<GetRegulation200Response> localVarResp = getRegulationWithHttpInfo(regulateId);
        return localVarResp.getData();
    }

    /**
     * Get Regulation Gets a regulation from the Workspace. Config API omitted fields: -
     * &#x60;parent&#x60;
     *
     * @param regulateId (required)
     * @return ApiResponse&lt;GetRegulation200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<GetRegulation200Response> getRegulationWithHttpInfo(String regulateId)
            throws ApiException {
        okhttp3.Call localVarCall = getRegulationValidateBeforeCall(regulateId, null);
        Type localVarReturnType = new TypeToken<GetRegulation200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Regulation (asynchronously) Gets a regulation from the Workspace. Config API omitted
     * fields: - &#x60;parent&#x60;
     *
     * @param regulateId (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getRegulationAsync(
            String regulateId, final ApiCallback<GetRegulation200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = getRegulationValidateBeforeCall(regulateId, _callback);
        Type localVarReturnType = new TypeToken<GetRegulation200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listRegulationsFromSource
     *
     * @param sourceId (required)
     * @param status The status on which to filter returned regulations. This parameter exists in
     *     v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listRegulationsFromSourceCall(
            String sourceId,
            String status,
            List<String> regulationTypes,
            PaginationInput pagination,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/regulations/sources/{sourceId}"
                        .replace(
                                "{" + "sourceId" + "}",
                                localVarApiClient.escapeString(sourceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (regulationTypes != null) {
            localVarCollectionQueryParams.addAll(
                    localVarApiClient.parameterToPairs(
                            "multi", "regulationTypes", regulationTypes));
        }

        if (pagination != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagination", pagination));
        }

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listRegulationsFromSourceValidateBeforeCall(
            String sourceId,
            String status,
            List<String> regulationTypes,
            PaginationInput pagination,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'sourceId' is set
        if (sourceId == null) {
            throw new ApiException(
                    "Missing the required parameter 'sourceId' when calling"
                            + " listRegulationsFromSource(Async)");
        }

        return listRegulationsFromSourceCall(
                sourceId, status, regulationTypes, pagination, _callback);
    }

    /**
     * List Regulations from Source Lists all Source-scoped regulations. Please note: List
     * regulations for Source only returns deletion requests from the past 90 days. Deletion
     * requests older than 90 days are not retained and will result in 404 resource not found.
     *
     * @param sourceId (required)
     * @param status The status on which to filter returned regulations. This parameter exists in
     *     v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @return ListRegulationsFromSource200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ListRegulationsFromSource200Response listRegulationsFromSource(
            String sourceId,
            String status,
            List<String> regulationTypes,
            PaginationInput pagination)
            throws ApiException {
        ApiResponse<ListRegulationsFromSource200Response> localVarResp =
                listRegulationsFromSourceWithHttpInfo(
                        sourceId, status, regulationTypes, pagination);
        return localVarResp.getData();
    }

    /**
     * List Regulations from Source Lists all Source-scoped regulations. Please note: List
     * regulations for Source only returns deletion requests from the past 90 days. Deletion
     * requests older than 90 days are not retained and will result in 404 resource not found.
     *
     * @param sourceId (required)
     * @param status The status on which to filter returned regulations. This parameter exists in
     *     v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @return ApiResponse&lt;ListRegulationsFromSource200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ListRegulationsFromSource200Response> listRegulationsFromSourceWithHttpInfo(
            String sourceId,
            String status,
            List<String> regulationTypes,
            PaginationInput pagination)
            throws ApiException {
        okhttp3.Call localVarCall =
                listRegulationsFromSourceValidateBeforeCall(
                        sourceId, status, regulationTypes, pagination, null);
        Type localVarReturnType =
                new TypeToken<ListRegulationsFromSource200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Regulations from Source (asynchronously) Lists all Source-scoped regulations. Please
     * note: List regulations for Source only returns deletion requests from the past 90 days.
     * Deletion requests older than 90 days are not retained and will result in 404 resource not
     * found.
     *
     * @param sourceId (required)
     * @param status The status on which to filter returned regulations. This parameter exists in
     *     v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listRegulationsFromSourceAsync(
            String sourceId,
            String status,
            List<String> regulationTypes,
            PaginationInput pagination,
            final ApiCallback<ListRegulationsFromSource200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                listRegulationsFromSourceValidateBeforeCall(
                        sourceId, status, regulationTypes, pagination, _callback);
        Type localVarReturnType =
                new TypeToken<ListRegulationsFromSource200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listSuppressions
     *
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listSuppressionsCall(
            PaginationInput pagination, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/suppressions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagination != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagination", pagination));
        }

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSuppressionsValidateBeforeCall(
            PaginationInput pagination, final ApiCallback _callback) throws ApiException {
        return listSuppressionsCall(pagination, _callback);
    }

    /**
     * List Suppressions Lists all suppressions in a given Workspace.
     *
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @return ListSuppressions200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ListSuppressions200Response listSuppressions(PaginationInput pagination)
            throws ApiException {
        ApiResponse<ListSuppressions200Response> localVarResp =
                listSuppressionsWithHttpInfo(pagination);
        return localVarResp.getData();
    }

    /**
     * List Suppressions Lists all suppressions in a given Workspace.
     *
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @return ApiResponse&lt;ListSuppressions200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ListSuppressions200Response> listSuppressionsWithHttpInfo(
            PaginationInput pagination) throws ApiException {
        okhttp3.Call localVarCall = listSuppressionsValidateBeforeCall(pagination, null);
        Type localVarReturnType = new TypeToken<ListSuppressions200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Suppressions (asynchronously) Lists all suppressions in a given Workspace.
     *
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listSuppressionsAsync(
            PaginationInput pagination, final ApiCallback<ListSuppressions200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = listSuppressionsValidateBeforeCall(pagination, _callback);
        Type localVarReturnType = new TypeToken<ListSuppressions200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listWorkspaceRegulations
     *
     * @param status The status on which to filter the returned regulations. This parameter exists
     *     in v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listWorkspaceRegulationsCall(
            String status,
            List<String> regulationTypes,
            PaginationInput pagination,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/regulations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (regulationTypes != null) {
            localVarCollectionQueryParams.addAll(
                    localVarApiClient.parameterToPairs(
                            "multi", "regulationTypes", regulationTypes));
        }

        if (pagination != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagination", pagination));
        }

        final String[] localVarAccepts = {
            "application/vnd.segment.v1+json",
            "application/json",
            "application/vnd.segment.v1beta+json",
            "application/vnd.segment.v1alpha+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"token"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listWorkspaceRegulationsValidateBeforeCall(
            String status,
            List<String> regulationTypes,
            PaginationInput pagination,
            final ApiCallback _callback)
            throws ApiException {
        return listWorkspaceRegulationsCall(status, regulationTypes, pagination, _callback);
    }

    /**
     * List Workspace Regulations Lists all Workspace-scoped regulations. Please note: List
     * Workspace regulations only returns deletion requests from the past 90 days. Deletion requests
     * older than 90 days are not retained and will result in 404 resource not found.
     *
     * @param status The status on which to filter the returned regulations. This parameter exists
     *     in v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @return ListWorkspaceRegulations200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ListWorkspaceRegulations200Response listWorkspaceRegulations(
            String status, List<String> regulationTypes, PaginationInput pagination)
            throws ApiException {
        ApiResponse<ListWorkspaceRegulations200Response> localVarResp =
                listWorkspaceRegulationsWithHttpInfo(status, regulationTypes, pagination);
        return localVarResp.getData();
    }

    /**
     * List Workspace Regulations Lists all Workspace-scoped regulations. Please note: List
     * Workspace regulations only returns deletion requests from the past 90 days. Deletion requests
     * older than 90 days are not retained and will result in 404 resource not found.
     *
     * @param status The status on which to filter the returned regulations. This parameter exists
     *     in v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @return ApiResponse&lt;ListWorkspaceRegulations200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ListWorkspaceRegulations200Response> listWorkspaceRegulationsWithHttpInfo(
            String status, List<String> regulationTypes, PaginationInput pagination)
            throws ApiException {
        okhttp3.Call localVarCall =
                listWorkspaceRegulationsValidateBeforeCall(
                        status, regulationTypes, pagination, null);
        Type localVarReturnType = new TypeToken<ListWorkspaceRegulations200Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Workspace Regulations (asynchronously) Lists all Workspace-scoped regulations. Please
     * note: List Workspace regulations only returns deletion requests from the past 90 days.
     * Deletion requests older than 90 days are not retained and will result in 404 resource not
     * found.
     *
     * @param status The status on which to filter the returned regulations. This parameter exists
     *     in v1. (optional)
     * @param regulationTypes The regulation types on which to filter returned regulations. This
     *     parameter exists in v1. (optional)
     * @param pagination Pagination parameters. This parameter exists in v1. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
     * <tr><td> 422 </td><td> Validation failure </td><td>  -  </td></tr>
     * <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listWorkspaceRegulationsAsync(
            String status,
            List<String> regulationTypes,
            PaginationInput pagination,
            final ApiCallback<ListWorkspaceRegulations200Response> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                listWorkspaceRegulationsValidateBeforeCall(
                        status, regulationTypes, pagination, _callback);
        Type localVarReturnType = new TypeToken<ListWorkspaceRegulations200Response>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
